
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jochenboesmans/go-rebase/model/market/market.go (100.0%)</option>
				
				<option value="file1">github.com/jochenboesmans/go-rebase/model/market/pair.go (100.0%)</option>
				
				<option value="file2">github.com/jochenboesmans/go-rebase/rebasing/rebasing.go (87.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package market

/**
Collection of pairs for which all market data is based in each pair's base token.
*/
type Market struct {
        PairsById map[string]Pair
}

type Neighbors struct {
        Base  []string
        Quote []string
}

func (m *Market) RebaseNeighbors() map[string]Neighbors <span class="cov8" title="1">{
        rebaseNeighbors := map[string]Neighbors{}

        for pairId := range m.PairsById </span><span class="cov8" title="1">{
                rebaseNeighbors[pairId] = Neighbors{
                        Base:  []string{},
                        Quote: []string{},
                }
        }</span>
        <span class="cov8" title="1">for pairAId, pairA := range m.PairsById </span><span class="cov8" title="1">{
                for pairBId, pairB := range m.PairsById </span><span class="cov8" title="1">{
                        if pairA.BaseId == pairB.QuoteId </span><span class="cov8" title="1">{
                                rebaseNeighbors[pairAId] = Neighbors{
                                        Base:  append(rebaseNeighbors[pairAId].Base, pairBId),
                                        Quote: rebaseNeighbors[pairAId].Quote,
                                }
                                rebaseNeighbors[pairBId] = Neighbors{
                                        Base:  rebaseNeighbors[pairBId].Base,
                                        Quote: append(rebaseNeighbors[pairBId].Quote, pairAId),
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">return rebaseNeighbors</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package market

import (
        "crypto/sha1"
        "encoding/hex"
        "fmt"
)

/**
Market pair containing data from one or many exchanges.
*/
type Pair struct {
        BaseId          string           `json:"baseId"`
        QuoteId         string           `json:"quoteId"`
        ExchangeMarkets []ExchangeMarket `json:"exchangeMarkets"`
}

/**
Exchange-specific market data.
*/
type ExchangeMarket struct {
        CurrentBid float32 `json:"currentBid"`
        CurrentAsk float32 `json:"currentAsk"`
        BaseVolume float32 `json:"baseVolume"`
}

func (p *Pair) Id() string <span class="cov8" title="1">{
        idString := fmt.Sprintf("%s/%s", p.BaseId, p.QuoteId)

        hash := sha1.New()
        hash.Write([]byte(idString))
        result := hash.Sum(nil)

        return hex.EncodeToString(result)
}</span>

func (p *Pair) CombinedBaseVolume() float32 <span class="cov8" title="1">{
        var sum float32 = 0
        for _, emd := range p.ExchangeMarkets </span><span class="cov8" title="1">{
                sum += emd.BaseVolume
        }</span>
        <span class="cov8" title="1">return sum</span>
}

func (p *Pair) BaseVolumeWeightedCurrentBidSum() float32 <span class="cov8" title="1">{
        var sum float32 = 0
        for _, emd := range p.ExchangeMarkets </span><span class="cov8" title="1">{
                sum += emd.BaseVolume * emd.CurrentBid
        }</span>
        <span class="cov8" title="1">return sum</span>
}

func (p *Pair) BaseVolumeWeightedCurrentAskSum() float32 <span class="cov8" title="1">{
        var sum float32 = 0
        for _, emd := range p.ExchangeMarkets </span><span class="cov8" title="1">{
                sum += emd.BaseVolume * emd.CurrentAsk
        }</span>
        <span class="cov8" title="1">return sum</span>
}

func (p *Pair) BaseVolumeWeightedSpreadAverage() float32 <span class="cov8" title="1">{
        spreadAverage := (p.BaseVolumeWeightedCurrentBidSum() + p.BaseVolumeWeightedCurrentAskSum()) / 2
        if p.CombinedBaseVolume() == float32(0) </span><span class="cov8" title="1">{
                return float32(0)
        }</span> else<span class="cov8" title="1"> {
                weightedAverage := spreadAverage / p.CombinedBaseVolume()
                return weightedAverage
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rebasing

import (
        "fmt"
        m "github.com/jochenboesmans/go-rebase/model/market"
        "sync"
)

type rebaseDirection uint8

const (
        BASE = iota + 1
        QUOTE
)

type rebasePathsType struct {
        Base  [][]string
        Quote [][]string
}

func RebaseMarket(rebaseId string, maxPathDepth uint8, market *m.Market) *m.Market <span class="cov8" title="1">{
        // shared data structures
        rebasedMarket := m.Market{PairsById: map[string]m.Pair{}}
        rebaseNeighbors := market.RebaseNeighbors()

        var waitGroup sync.WaitGroup
        for pairId := range market.PairsById </span><span class="cov8" title="1">{
                waitGroup.Add(1)
                rebasePair(pairId, rebaseId, maxPathDepth, market, &amp;rebasedMarket, rebaseNeighbors, &amp;waitGroup)
        }</span>
        <span class="cov8" title="1">waitGroup.Wait()
        return &amp;rebasedMarket</span>
}

func rebasePair(pairId string, rebaseId string, maxPathDepth uint8, market *m.Market, rebasedMarket *m.Market, rebaseNeighbors map[string]m.Neighbors, waitGroup *sync.WaitGroup) <span class="cov8" title="1">{
        // determine all paths from the current pair to pairs based in rebaseId
        rebasePaths := rebasePathsType{
                Base:  rebasePaths(BASE, []string{pairId}, rebaseId, maxPathDepth, market, rebaseNeighbors),
                Quote: rebasePaths(QUOTE, []string{pairId}, rebaseId, maxPathDepth, market, rebaseNeighbors),
        }

        originalMarketPair := market.PairsById[pairId]

        // deeply rebase all rates based on the available rebasePaths
        var newExchangeMarkets []m.ExchangeMarket
        for _, emd := range originalMarketPair.ExchangeMarkets </span><span class="cov8" title="1">{
                newExchangeMarket := m.ExchangeMarket{
                        CurrentBid: deeplyRebaseRate(emd.CurrentBid, rebaseId, rebasePaths, market),
                        CurrentAsk: deeplyRebaseRate(emd.CurrentAsk, rebaseId, rebasePaths, market),
                        BaseVolume: deeplyRebaseRate(emd.BaseVolume, rebaseId, rebasePaths, market),
                }
                newExchangeMarkets = append(newExchangeMarkets, newExchangeMarket)
        }</span>

        // copy pair data to rebased pair
        <span class="cov8" title="1">rebasedMarket.PairsById[pairId] = m.Pair{
                BaseId:          market.PairsById[pairId].BaseId,
                QuoteId:         market.PairsById[pairId].QuoteId,
                ExchangeMarkets: newExchangeMarkets,
        }

        waitGroup.Done()</span>
}

func rebasePaths(direction rebaseDirection, pathAccumulator []string, rebaseId string, maxPathDepth uint8, market *m.Market, rebaseNeighbors map[string]m.Neighbors) [][]string <span class="cov8" title="1">{
        if len(pathAccumulator) &gt; int(maxPathDepth) </span><span class="cov8" title="1">{
                return [][]string{}
        }</span> else<span class="cov8" title="1"> {
                lastPairId := pathAccumulator[0]
                lastBaseId := market.PairsById[lastPairId].BaseId
                if lastBaseId == rebaseId </span><span class="cov8" title="1">{
                        return [][]string{pathAccumulator}
                }</span> else<span class="cov8" title="1"> {
                        return doRebasePaths(direction, pathAccumulator, rebaseId, maxPathDepth, market, rebaseNeighbors)
                }</span>
        }
}

func doRebasePaths(direction rebaseDirection, pathAccumulator []string, rebaseId string, maxPathDepth uint8, market *m.Market, rebaseNeighbors map[string]m.Neighbors) [][]string <span class="cov8" title="1">{
        var nextNeighborIds []string
        if direction == BASE </span><span class="cov8" title="1">{
                nextNeighborIds = rebaseNeighbors[pathAccumulator[0]].Base
        }</span> else<span class="cov8" title="1"> if direction == QUOTE </span><span class="cov8" title="1">{
                nextNeighborIds = rebaseNeighbors[pathAccumulator[0]].Quote
        }</span>

        <span class="cov8" title="1">var result [][]string
        for _, nextNeighborId := range nextNeighborIds </span><span class="cov8" title="1">{
                nextPath := append([]string{nextNeighborId}, pathAccumulator...)
                result = append(result, rebasePaths(direction, nextPath, rebaseId, maxPathDepth, market, rebaseNeighbors)...)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func deeplyRebaseRate(rate float32, rebaseId string, rebasePaths rebasePathsType, market *m.Market) float32 <span class="cov8" title="1">{
        combinedVolume := float32(0)
        volumeWeightedSum := float32(0)
        for _, baseRebasePath := range rebasePaths.Base </span><span class="cov8" title="1">{
                rebasedRateAcc := rate
                weightedSumAcc := float32(0)
                for i := len(baseRebasePath) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        pair := market.PairsById[baseRebasePath[i]]
                        baseId := pair.BaseId
                        quoteId := pair.QuoteId
                        if rebasedRate, err := shallowlyRebaseRate(rebasedRateAcc, baseId, quoteId, market); err == nil </span><span class="cov8" title="1">{
                                rebasedRateAcc = rebasedRate
                        }</span>
                        <span class="cov8" title="1">combinedVolume := pair.CombinedBaseVolume()
                        if rebasedCombinedVolume, err := shallowlyRebaseRate(combinedVolume, rebaseId, baseId, market); err == nil </span><span class="cov8" title="1">{
                                weightedSumAcc += rebasedCombinedVolume
                        }</span>
                }
                <span class="cov8" title="1">weight := weightedSumAcc / float32(len(baseRebasePath))
                combinedVolume += weight
                volumeWeightedSum += weight * rebasedRateAcc</span>
        }

        <span class="cov8" title="1">for _, quoteRebasePath := range rebasePaths.Quote </span><span class="cov8" title="1">{
                rebasedRateAcc := rate
                weightedSumAcc := float32(0)
                for i := len(quoteRebasePath) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        pair := market.PairsById[quoteRebasePath[i]]
                        baseId := pair.BaseId
                        quoteId := pair.QuoteId
                        if i == 0 </span><span class="cov8" title="1">{
                                combinedVolume := pair.CombinedBaseVolume()
                                if rebasedCombinedVolume, err := shallowlyRebaseRate(combinedVolume, rebaseId, baseId, market); err == nil </span><span class="cov8" title="1">{
                                        weightedSumAcc += rebasedCombinedVolume
                                }</span>
                        } else<span class="cov0" title="0"> if i == len(quoteRebasePath)-1 </span><span class="cov0" title="0">{
                                if rebasedRate, err := shallowlyRebaseRate(rebasedRateAcc, quoteId, baseId, market); err == nil </span><span class="cov0" title="0">{
                                        rebasedRateAcc = rebasedRate
                                }</span>
                        } else<span class="cov0" title="0"> {
                                pair := market.PairsById[quoteRebasePath[i]]
                                baseId := pair.BaseId
                                quoteId := pair.QuoteId
                                if rebasedRate, err := shallowlyRebaseRate(rebasedRateAcc, quoteId, baseId, market); err == nil </span><span class="cov0" title="0">{
                                        rebasedRateAcc = rebasedRate
                                }</span>
                                <span class="cov0" title="0">combinedVolume := pair.CombinedBaseVolume()
                                if rebasedCombinedVolume, err := shallowlyRebaseRate(combinedVolume, rebaseId, baseId, market); err == nil </span><span class="cov0" title="0">{
                                        weightedSumAcc += rebasedCombinedVolume
                                }</span>
                        }
                }
                <span class="cov8" title="1">weight := weightedSumAcc / float32(len(quoteRebasePath))
                combinedVolume += weight
                volumeWeightedSum += weight * rebasedRateAcc</span>
        }

        <span class="cov8" title="1">if combinedVolume == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span> else<span class="cov8" title="1"> {
                return volumeWeightedSum / combinedVolume
        }</span>
}

func shallowlyRebaseRate(rate float32, rebaseId string, baseId string, market *m.Market) (float32, error) <span class="cov8" title="1">{
        if rebaseId == baseId </span><span class="cov8" title="1">{
                return rate, nil
        }</span> else<span class="cov8" title="1"> {
                rebasePair := m.Pair{
                        BaseId:  rebaseId,
                        QuoteId: baseId,
                }
                if matchingMarketPair, ok := market.PairsById[rebasePair.Id()]; !ok </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf(`no pair in market to rebase baseId "%s" to rebaseId "%s"`, baseId, rebaseId)
                }</span> else<span class="cov8" title="1"> {
                        matchingMarketPairBaseVolumeWeightedSpreadAverage := matchingMarketPair.BaseVolumeWeightedSpreadAverage()
                        return matchingMarketPairBaseVolumeWeightedSpreadAverage * rate, nil
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
